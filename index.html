<canvas id="gc" width="400" height="400"></canvas>

<script>
    //classes and global functions and variables
    var bulletsSet, helisSet, troopersSet, keys;
	
	function deleteEntities(){
		for (e of entitiesSet) {
            if(e.y < (0 - this.height) || e.x <(0-this.width) || e.x >(400 + this.width)){
				entitiesSet.delete(this);
			}
        }
	}
	
	function checkCollisions(){
	//performance issues caused here!!
		/*let tempArray = Array.from(entitiesSet);
		let bulletsArray = tempArray.filter(val => {return (val instanceof Bullet)});
		let troopersAndHelisArray = tempArray.filter(val => {return (val instanceof Trooper) || (val instanceof Helicopter)});
		for (b of bulletsArray) {
			for(t of troopersAndHelisArray){
				if (b.x < t.x + t.width && // credit: https://developer.mozilla.org/kab/docs/Games/Techniques/2D_collision_detection
					b.x + b.width > t.x &&
					b.y < t.y + t.height &&
					b.height + b.y > t.y) {
					t.hit();               //include set timeout here?
				}
			}
        }
		*/
	}

	function spawn_heli(){
		// can improve by having helis spawn on 2 levels and have going left and right
		let direction = 'r';
		let y = -5;
		if(Math.round(Math.random())){
			direction = 'l';
		}
		if(Math.round(Math.random())){
			y = 30;
		}
	
		entitiesSet.add(new Helicopter(direction,y));
		// can play around with time out values and use variables to make them spawn 
		// faster as game progresses
		setTimeout(spawn_heli,Math.floor(2000+(Math.random() * 9000) + 1));
		
	}
	
    function drawGame() {
        for (e of entitiesSet) {
            e.display();
        }
    }

    function moveEntities() {
        for (e of entitiesSet) {
            e.move();
        }
    }

    class Entity {
        constructor(src, x, y, w, h) {
            this.image = new Image();
            this.image.src = src;
            this.x = x;
            this.y = y;
            this.xSpeed = 0;
            this.ySpeed = 0;
            this.width = w;
            this.height = h;
        }

        display() {
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        }

        move() {
            this.x += this.xSpeed;
            this.y += this.ySpeed;
        }
		

    }

    class Helicopter extends Entity {
        constructor() {
			if(arguments.length == 2){
				if(arguments[0]=='r'){
					super('./helicopter_right.png', -75, arguments[1], 75, 70);
					this.xSpeed = 0.5;
				}else{
					super('./helicopter_left.png', 475, arguments[1], 75, 70);
					this.xSpeed = -0.5;
				}
				
			}else{
				super('./helicopter_right.png', -75, -5, 75, 70);
				this.xSpeed = 0.5;
			}
			
        }
		hit(){
			this.image.src = './helicopter_right_red.png';
		}
    }

    class Trooper extends Entity {
        constructor(src, x, y, w, h) {
            super('./para.png', 10, 10, 40, 40);
            this.ySpeed = 1.5;
        }

        move() {
            this.y += this.ySpeed;
            if (this.y > 355) {
                this.ySpeed = 0;
            }
        }
		
		hit(){
			this.image.src = './para_red.png';
		}
    }

    class Bullet extends Entity {
        constructor(x, y, xVec, yVec, rotation) {
            super('./bullet.png', x, y, 10, 10);
            this.xSpeed = xVec * 2.5;
            this.ySpeed = yVec * 2.5;
            this.rotation = rotation;
        }

        display() {
            drawImageRot(this.image, this.x, this.y, this.width, this.height, this.rotation);
        }
		
				
    }

    class Turret extends Entity {
        constructor(src, x, y, w, h) {
            super('./turret.png', 165, 350, 50, 120);
            this.rotation = 0;
        }

        display() {
            drawImageRot(this.image, this.x, this.y, this.width, this.height, this.rotation);
        }

        rotate(x) {
            this.rotation += x;
        }

    }

	// initialise game
    window.onload = function() {
        canv = document.getElementById("gc");
		ctx = canv.getContext("2d");
		
        entitiesSet = new Set();
		entitiesSet.add(new Turret());
		entitiesSet.add(new Helicopter());
		entitiesSet.add(new Trooper());
		
		
        keys = [];
		bulletFlag = true; // todo: find a place or way to set this privately
		
		setTimeout(spawn_heli,3000);
        setInterval(game, 1000 / 200);
        setInterval(keyPress, 1000 / 50);
    }

    // game loop
    function game() {
        // clear screen
        ctx.fillStyle = "LightGrey";
        ctx.fillRect(0, 0, canv.width, canv.height);
        moveEntities();
        checkCollisions();
        drawGame();
		deleteEntities();
    }

	// keypress loop
    function keyPress() {
        let turr = entitiesSet.values().next().value; // better way to access elements in set?
        if (keys[39] && turr.rotation < 72) { // turn right with right arrow
            turr.rotate(3);
		}
		
        if (keys[37] && turr.rotation > -72) { // turn left with left arrow
            turr.rotate(-3);
		}
		
        if (keys[32] && bulletFlag) { // fire a bullet when space is pressed
            // calculate radians as thats what the Math lib uses
            var rad = -turr.rotation * Math.PI / 180 + Math.PI / 2;

            // the vectors that the bullets will fire on
            var xVec = Math.cos(rad);
            var yVec = -Math.sin(rad);

            // finding the point in the arc that the bullet will spawn
            // X:= originX + cos(angle) * radius;
            // Y:= originY + sin(angle) * radius;
            var x = 186 + xVec * 44;
            var y = 404 + yVec * 44;

            // create bullet
            entitiesSet.add(new Bullet(x, y, xVec, yVec, turr.rotation));
            bulletFlag = false; // set delay so that a stream of bullets isn't fired
            setTimeout(function() {
                bulletFlag = true
            }, 150);
        }
    }

    onkeydown = onkeyup = function(e) {
        //run on every interaction of a key, sets the keys state to an array value
        keys[e.keyCode] = e.type === 'keydown';
    };

    // Credit: https://stackoverflow.com/a/11985464
    function drawImageRot(img, x, y, width, height, deg) {
        //Convert degrees to radian 
        var rad = deg * Math.PI / 180;

        //Set the origin to the center of the image
        ctx.translate(x + width / 2, y + height / 2);

        //Rotate the canvas around the origin
        ctx.rotate(rad);

        //draw the image    
        ctx.drawImage(img, width / 2 * (-1), height / 2 * (-1), width, height);

        //reset the canvas  
        ctx.rotate(rad * (-1));
        ctx.translate((x + width / 2) * (-1), (y + height / 2) * (-1));
    }

</script>
